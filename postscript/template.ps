%!PS-Adobe-3.0
%%Pages: 1
%%EndComments
%%DocumentNeededResources: font Helvetica Helvetica-Bold
%%+ font Helvetica-BoldOblique Helvetica-Oblique Courier Courier-Bold
%
% This document included in .ps files generated by cdlabelgen
%
% Author: Avinash Chopde <avinash@aczoom.com>  www.aczoom.com
% =========================================================================
% Copyright (C) 1998, 1999 B. W. Fitzpatrick <fitz@red-bean.com>
% Copyright (C) 2001-2005 Avinash Chopde <avinash@aczoom.com> http://www.aczoom.com/
%
% All rights reserved.
% --------------------
% WEB-SCRIPT-MESSAGES-HERE
% --------------------
%
% Permission is hereby granted, free of charge, to any person obtaining a
% copy of this software and associated documentation files (the
% "Software"), to deal in the Software without restriction, including
% without limitation the rights to use, copy, modify, merge, publish,
% distribute, and/or sell copies of the Software, and to permit persons
% to whom the Software is furnished to do so, provided that the above
% copyright notice(s) and this permission notice appear in all copies of
% the Software and that both the above copyright notice(s) and this
% permission notice appear in supporting documentation.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
% OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
% HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
% INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
% FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
% NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
% WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
%
% Except as contained in this notice, the name of a copyright holder
% shall not be used in advertising or otherwise to promote the sale, use
% or other dealings in this Software without prior written authorization
% of the copyright holder.
% =========================================================================
% Created: October 1998 by B. W. Fitzpatrick <fitz@red-bean.com>
% =========================================================================
% mar 01 avinash: attempt to remove all unrecognized DSC comments warnings.
% added %%Pages, %%Page, %%BeginDocument, etc and many %% changed to %
% added new features, fixed bug where items could be dropped
% apr 01 avinash: support for slim-cd cases -
%                 prints two-page folding covers, no traycard
% -- added option to scale image to fill cover or traycard - so that it
% can be a background image.
% jun 01 avinash: re-fix bug - dropping items if how_many_items not
%    a multiple of num_cols, I am sure I've got it correct now!
%    (search for "ceil" to locate code fixed) [july: fix no longer needed]
% jul 01 avinash: - add guide lines to indicate cuts and folds
%    - major addition : much better figuring out optimum font size
%      to use for the items - uses both the number of items and
%      width of largest item to figure this out. This eliminates the need for
%      above fix for how_many_items/ceil, and makes it possible to use
%      to use fixed font size for list of items which looks much better
%      than a varying font size for the items on the tray card.
%    - to enable use of the fixed font size for all items, use the
%      -p option to cdlabelgen ( resets enable_item_scaling_p here )
%      this will then make all items with same font size, and clip text
%      if needed - text is clipped by chopping off letters from end
%      of string (if it is too wide to fit) 
% oct 01 avinash - redo endcap_text, to make subtitle fit correctly
% dec 01 avinash - add option to fill image in tray and end-caps too
%      in addition to just tray 	[version 2.1.4]
% jan 02 avinash - now capable of printing items on both cover and tray,
%      handle upto 500 items (approx)	[version 2.2.0]
% apr 02 avinash - merge in code for envelope printing [version 2.3.0]
%      merged in envelope template by Ronald Rael Harvest <number6@cox.net>
% jul 02 avinash - fill2 background should fill two endcaps only, [2.4.0]
%      do not fill the extreme right-hand tongue-cap
%    - added image offset for both cover and tray
%    - added line width specification for cover/tray edge lines
% aug 02 avinash - added support for latin2 encoding also [2.5.0]
% aug 02 alessandro - added color support for plaque background, category
%      text, subcategory text, text	[2.5.0]
% May 2003  From Mathias Herberts <Mathias.Herberts@iroise.net> [2.6.0]
%	- Adds the option to output slim cd cover cases with the order of the
%	- pages switched so the folding line lies on the outside
%	- of a normal cd case.
% July 2003  Updates from Tony Mancill <tmancill@debian.org>
%  --no-cover-plaque
%  --number-in-set <string>
% Nov 2003  Added DVD support - just inside inserts for now [2.7.0]
%	Move down DVD insert 0.5 inches (like envelope) for better fit on
%	A4 paper [2.7.1]
%	Add support for dvd-outside cover inserts [3.0.0]
%	"fill2" now fills tray+cover for slim cd, dvd inside/outside output
%	"fill2" for normal cd case is unchanged - fill tray+endcaps
% Dec 2004 [3.1.0]
%	Longer fold lines
%	Monospaced font support (#M), rotate end caps
%	Added support for slim dvd cases (half thickness of normal DVD cases)
%	Changed if_do_slim_cdcase to if_do_slim_case
%	 - if_do_cd_inside_insert is set if no DVD option provided
%	 - if DVD outside, then slim_case implies half-height DVD case
%	 - DVD inside option is the same
% Jan 2005 [3.5.0]
%	Added do_cdlabel: support for cd labels - printing on CD/DVD directly
% Aug 2005 [3.6.0]
%	Added force_rows, force_columns, use these values, don't compute
%       line_height or num_columns
% Apr 2007 [4.0.0]
%	Added tray_overlay support, overprints EPS file on tray.
%       Use in conjunction with "barcodegen" to print barcodes, for example.
%       Created function position_tray_image.
% Oct 2008 [4.1.0]
%   Create covers for double-sided DVD cases that hold 6 DVDs.
%   --double-case option now available, to be used with dvd-outside option.
%   Thanks to Andras Salamon <asalamon@chello.hu> for this patch.
% Apr 2012 [4.2.0]
%   Support for double-depth slim DVD cases. --slim-double-case option. 
%   Patch sent by Dominique Dumont dod@debian.org
% =========================================================================
% Reencode the font to support international characters.
% avinash, aug 02: removed code from here, use the ogonkify package
% to encode as required, pipe the output from cdlabelgen into:
% ogonkify -H -e<encoding>
% where encoding is L1, or L2, or L3 etc... (latin1, latin2, latin3, etc)
%
% To support filtering by ogonkify, do my Latin1 reencoding before
% the BeginProlog statement - that is where ogonkify inserts its new
% encoding, which will override the reencodeL1 in the following lines.

/reencodeL1 {
  dup dup findfont dup length dict begin
     { 1 index /FID ne { def }{ pop pop } ifelse } forall
     /Encoding ISOLatin1Encoding def	% PostScript Level 2 command
     currentdict end definefont
} def
    
/Helvetica reencodeL1 def	% used for normal text items
/Helvetica-Bold reencodeL1 def	% for bold text items, category, sub-category
/Helvetica-BoldOblique reencodeL1 def	%  for bold italic text items
/Helvetica-Oblique reencodeL1 def	%  for italic text items		
/Courier reencodeL1 def	        % used for monospace text items
/Courier-Bold reencodeL1 def	        % used for monospace text items
%----------------------------------------------------------------------

%%BeginProlog
% ogonkify encoding will be inserted above if ogonkify processes this file

% Helvetica % used for normal text items
% Helvetica-Bold % for bold text items, category, sub-category
% Helvetica-BoldOblique %  for bold italic text items
% Helvetica-Oblique %  for italic text items		
% Courier % used for monospace text items
% Courier-Bold % used for monospace text items
    
%=========================================================================
% Colors related stuff
% (added by alessandro aug 02)
/r_plaque_color TOKEN_R_PLAQUE_COLOR def
/g_plaque_color TOKEN_G_PLAQUE_COLOR def
/b_plaque_color TOKEN_B_PLAQUE_COLOR def

/r_category_color TOKEN_R_CATEGORY_COLOR def
/g_category_color TOKEN_G_CATEGORY_COLOR def
/b_category_color TOKEN_B_CATEGORY_COLOR def

/r_subcategory_color TOKEN_R_SUBCATEGORY_COLOR def
/g_subcategory_color TOKEN_G_SUBCATEGORY_COLOR def
/b_subcategory_color TOKEN_B_SUBCATEGORY_COLOR def

/r_text_color TOKEN_R_TEXT_COLOR def
/g_text_color TOKEN_G_TEXT_COLOR def
/b_text_color TOKEN_B_TEXT_COLOR def
%=========================================================================
/in {72 mul } def

% Font related stuff
/banfont /Helvetica-Bold def
/cover_ban_size 42 def
/tray_ban_size 42 def
/bansize 42 def

/subbanfont /Helvetica-Bold def
/cover_subban_size 24 def
/tray_subban_size 24 def
/subbansize 24 def

/notefontname /Helvetica-Bold def
/notefontsize 12 def
/datefontsize 12 def
/date_height datefontsize 1.667 mul def % for 12pt text, this becomes 20pt

/normalfontname /Helvetica def
/itemfontname normalfontname def
% mar 01: avinash added support for keywords in "items", start in 1st column
% {#BI} will use bold italic, {#B} bold, {#I} italic, {#M} monospaced
/BIitemfontname /Helvetica-BoldOblique def % bold-italic item font name
/Bitemfontname /Helvetica-Bold def % bold item font name
/Iitemfontname /Helvetica-Oblique def % italic item font name
/Mitemfontname /Courier def % monospaced - courier item font name
/MBitemfontname /Courier-Bold def % monospaced bold - courier item font name
/normalfontsize 10 def

% list of items - min height, max height, max columns for items, etc
/max_item_line_height 12 def
/min_item_line_height 5.2 def

%Jan Prikryl correction:
%/line_item_diff -0.6 def % == line_height - item_size (font size), in points
/line_item_diff -0.2 def % == line_height - item_size (font size), in points

/max_columns 5 def
/column_gutter 8 def  % each col is column_gutter away from next col or border

% Spacers between text in end caps
/ytextspacer 5 def
/notespacer { ytextspacer dup rmoveto } def

/epsilon_point 0.4 def % for floating point comparisions of points on page...
/epsilon epsilon_point 1000 div def % for floating point comparisions

%=========================================================================
% Constants
/print_traycard_plaque_p TOKEN_TRAY_PLAQUE_P def
/print_cover_plaque_p TOKEN_COVER_PLAQUE_P def

/enable_item_scaling_p TOKEN_ENABLE_ITEM_SCALING_P def

/outside_foldout_p TOKEN_OUTSIDE_FOLDOUT_P def

/rotate_endcaps_p TOKEN_ROTATE_ENDCAPS_P def

% page offsets for all printing - to accomodate different paper margins
/yoffset TOKEN_Y_OFFSET_INCHES in def % use 0.8 for letter, 1.5 for A4 paper
/xoffset TOKEN_X_OFFSET_INCHES in def

% images on cover and tray card image can be offset as required
% when they are not being used to fill entire backgrounds
/tray_image_xoffset TOKEN_TRAY_IMAGE_X_OFFSET_INCHES in def
/tray_image_yoffset TOKEN_TRAY_IMAGE_Y_OFFSET_INCHES in def
/cover_image_xoffset TOKEN_COVER_IMAGE_X_OFFSET_INCHES in def
/cover_image_yoffset TOKEN_COVER_IMAGE_Y_OFFSET_INCHES in def
/tray_overlay_image_xoffset TOKEN_TRAY_OVERLAY_IMAGE_X_OFFSET_INCHES in def
/tray_overlay_image_yoffset TOKEN_TRAY_OVERLAY_IMAGE_Y_OFFSET_INCHES in def

% width of the lines used to draw the edges for the cover, tray, endcaps
% in points, 1 == 1/72", 0 will suppress drawing of line
/edge_line_width TOKEN_EDGE_LINE_WIDTH def

% for normal sized cases, space between cover & tray
% used to be 20, but made it touching - so now cover and tray nearly touch
% each other, and a single cut can separate the cover/tray 
% /tray_cover_gap  1 def
/tray_cover_gap  edge_line_width  def

% instead of having this program compute the number of rows and number of
% columns for the list of items, users can override the internal
% computation, and specify the #rows (#lines), and #columns
% 0 means do internal computatation (determine_line_heights, etc)
/force_count_rows	TOKEN_COUNT_ROWS def
/force_count_cols	TOKEN_COUNT_COLS def

%=========================================================================
% output mode 
% Only one of above booleans should be set to true... (no checks are made
% here (cdlabelgen perl script does the checking)  - strange output
% may result if more than one is true)

/if_do_normal_cdcase TOKEN_NORMAL_CDCASE def
% if == true: print for normal sized CD cases - one page cover, and tray card

/if_do_envelope TOKEN_ENVELOPE_CDCASE def
% if == true: print envelope for CDs

/if_do_dvd_inside_insert TOKEN_INSIDE_DVDCASE def
% if == true: print inside insert for DVD cases

/if_do_dvd_outside_cover TOKEN_OUTSIDE_DVDCASE def
% if == true: print outside cover for DVD cases

/if_do_cdlabel TOKEN_CDLABEL def
% if == true: print directly on CD/DVD
% -------------------------------------------------------------------------
/if_do_slim_case TOKEN_SLIM_CASE def
% if == true: print slim-sized CD (cd_inside_insert) or DVD cases
%    - two page folding cover, no tray
%	 - if DVD outside, then slim_case implies half-height DVD case
%	 - DVD inside option is the same
/if_do_slim_double_case TOKEN_SLIM_DOUBLE_CASE def
% if == true: print 1.5 x DVD cases
/if_do_double_case TOKEN_DOUBLE_CASE def
% if == true: print double-sized CD (cd_inside_insert) or DVD cases
%    - two page folding cover, no tray
%	 - if DVD outside, then double_case implies double-height DVD case
%	 - DVD inside option is the same

%% Sanity Checks
/if_do_cd_inside_insert false def
if_do_slim_case if_do_dvd_outside_cover not and
  { /if_do_cd_inside_insert true def } if

if_do_dvd_inside_insert if_do_cd_inside_insert or not
  { /outside_foldout_p false def } if

% -------------------------------------------------------------------------

/tng_width .375 in def            % Width of the tongue

%Jan Prikryl correction:
%/cap_width .25 in def            % Width of the endcap
/cap_width .256 in def            % Width of the endcap

% define parameters based on what is being printed - normal cd case
if_do_normal_cdcase {
%Jan Prikryl correction:
%  /tray_height 4.625 in def           % Height of the traycard
%  /tray_width { 5.406 in } def   % Width of the traycard
  /tray_height 4.638 in def       % Height of the traycard
  /tray_width { 5.433 in } def    % Width of the traycard
  /tray_margin 0.1 in def
  /tray_width_printable { tray_width tray_margin 2 mul sub } def
%  /cover_height { 4.72 in } def  % Height of the cover
%  /cover_width { 4.75 in } def   % Width of the cover
  /cover_height { 4.724 in } def  % Height of the cover
  /cover_width { 4.763 in } def   % Width of the cover
  /cover_margin 0.1 in def
  /cover_width_printable { cover_width cover_margin 2 mul sub } def
} if
% define parameters based on what is being printed - slim cd case
if_do_cd_inside_insert {
  /cover_height { 4.724 in } def % Height of the cover
  /cover_width { 4.763 in } def  % Width of the cover
  /cover_margin 0.1 in def
  /cover_width_printable { cover_width cover_margin 2 mul sub } def
  /tray_height cover_height def    /tray_width  cover_width def
  /tray_margin 0.1 in def
  /tray_width_printable { tray_width tray_margin 2 mul sub } def
  /tray_height_normal 4.625 in def %%NOTUSED?
  /cap_width 0 def
} if
% define parameters based on what is being printed - envelope for cd
if_do_envelope {
  /top_flap_height 0.7 in def
  /side_flap_width   cap_width 0.10 in  add  def % must be >= cap_width
  /cover_height { 4.9 in } def     % Height of the CD envelope
  /cover_width { 4.875 in } def    % Width of the CD envelope
  /cover_margin 0.1 in def
  /cover_width_printable { cover_width cover_margin 2 mul sub } def
  /tray_height cover_height def    /tray_width  cover_width def
  /tray_margin 0.05 in side_flap_width add def
  /tray_width_printable { tray_width tray_margin 2 mul sub } def
} if
% define parameters based on what is being printed - DVD inside insert
% (somewhat like a slim cd case)
if_do_dvd_inside_insert {
  /cover_height { 7.185 in } def % Height of the insert
  /cover_width { 4.823 in } def  % Width of the insert
  /cap_width 0 def
  /cover_margin 0.1 in def
  /cover_width_printable { cover_width cover_margin 2 mul sub } def
  /tray_height cover_height def    /tray_width  cover_width def
  /tray_margin 0.1 in def
  /tray_width_printable { tray_width tray_margin 2 mul sub } def
  /tray_height_normal 4.625 in def %%NOTUSED?
} if
if_do_dvd_outside_cover {
  /cover_height { 7.188 in } def % Height of the insert
  /cover_width { 5.094 in } def  % Width of the front/back of insert
    % cap_width -  Width of the spine - second_endcap funtion
  if_do_slim_case % slim dvd thickness - half normal DVD
    { /cap_width 0.281 in def  /notefontsize 15 def  /ytextspacer 5 def }
    {
      if_do_double_case % double dvd thickness - twice normal DVD
      { /cap_width 1.0625 in def  /notefontsize 60 def  /ytextspacer 20 def }    
      {
	  if_do_slim_double_case % 1.5 times normal DVD
	  { /cap_width 0.843 in def  /notefontsize 45 def  /ytextspacer 15 def }    
	  { /cap_width 0.562 in def  /notefontsize 30 def  /ytextspacer 10 def }
	  ifelse
      }
      ifelse
    }
    ifelse
  % full cover width is: 5.094" + 0.562" + 5.094" = 10.75"
  /cover_margin 0.1 in def
  /cover_width_printable { cover_width cover_margin 2 mul sub } def
  /tray_height cover_height def    /tray_width  cover_width def
  /tray_margin 0.1 in def
  /tray_width_printable { tray_width tray_margin 2 mul sub } def
  /tray_height_normal 4.625 in def %%NOTUSED?
  /tray_cover_gap 0 def
} if
if_do_cdlabel {
  /inner_radius { 1.496 in 2 div } def
  /outer_radius { 4.567 in 2 div } def

  % cover / tray height is the height of box used to print all text
  /cover_height 1.1 in def % Height of the text area -
  /tray_height cover_height def
  % !!! must be less than (outer_radius - inner_radius) otherwise
  % cover_width computation below will error out
  % textbox_width = 2*sqrt( outer_radius^2 - (inner_radius + textbox_height)^2 )

  /cover_width 
     outer_radius dup mul 
     inner_radius cover_height add dup mul
     sub sqrt
     2 mul
  def

  % (computed text box width) == cover_width == %debug

  /outer_diameter outer_radius outer_radius add def
  /tray_width  cover_width def
  /cover_width_printable cover_width def
  /tray_width_printable tray_width def
  /cover_margin 0 def
  /tray_margin cover_margin def
  /cap_width 0 def
  /notefontname /Helvetica def
  /datefontsize 7 def
  /date_height 0 def % date string is printed along outer CD diameter, not on cover
} if

% the logo may be printed as a background image, in which case
% the "logo" is scaled asymetrically in X & Y axis, and differently
% for cover and tray card. If the "cdlabelgen" program defines scaleratio==0.0
% then the logo is used as background, otherwise not.
/yscale 1.0 def
/xscale 1.0 def

% if scaleratio is 0.0, then the image fills the tray, and the
% trayimage_fill_all determines whether to scale to fit just the tray
% or scale to fit the tray + endcaps region (but not the tongue-end-cap)
% applies to tray only, does not apply to cover [normalcdcase output]
% fill_all implies fill tray, cover, spine - for slim cd, and
% dvd inside & outside. Option "-T fill2" enables this
/trayimage_fill_all false def

% slope - percent slant to top/side flaps, envelope printing
/slope 0.1 def

%=========================================================================
% Begin Procedures

% Auto scale the font to deal with strings that might be too long
% Push onto the stack: font, pt size, string, max_width,
% and we'll set the font to the right size so it isn't too wide.
% note: uses 20 pt buffer - so max_width is reduced by 20 pts for computation
% also: does not scale up pt_size, just scales down if needed
/auto_reduce_font {
  % load up the vars from the stack into local vars.
  /the_max_width exch 20 sub def
  /the_string exch def
  /pt_size exch def
  /font_to_scale exch def

  % Set the font that we're going to use
  font_to_scale findfont [ pt_size 0 0 pt_size 0 0 ] makefont setfont

  % Get the width of the string
  /width_string {the_string stringwidth pop} def
  /width_scale 1 def   % set to 1 for width computation.

  % If our string is wider than max width, get our scale ratio
  width_string the_max_width gt
    { /width_scale {the_max_width width_string div} def}
  if
  % leave the new point size on the stack
  pt_size width_scale mul
} def

% Auto truncate the string to deal with strings that might be too long
% Push onto the stack: font, pt size, string, max_width,
% keeps removing characters from end of string, until the string fits
% in given width
/auto_reduce_string {
  % load up the vars from the stack into local vars.
  /the_max_width exch 20 sub def
  /the_string exch def
  /pt_size exch def
  /font_to_scale exch def

  % Set the font that we're going to use
  font_to_scale findfont [ pt_size 0 0 pt_size 0 0 ] makefont setfont

  % keep checking width of string with 1..n chars, 1..n-1 chars, etc
  % until we get a string that fits in given width
  /the_string_length the_string length def
  the_string_length {

    /the_string  the_string 0 the_string_length getinterval  def

    the_string stringwidth pop % x-width
    the_max_width
    le { exit } if % fits width, so found string

    /the_string_length the_string_length 1 sub def
  } repeat

  % leave the new string on the stack
  the_string
} def

% mar 01 avinash: Function: Concatenates two strings together, from:
% http://www.cc.iastate.edu/olc_answers/packages/graphics/postscript.faq.html
% string1 string2 append string
/append {
   2 copy length exch length add  % find the length of the new.
   string dup     % string1 string2 string string
   4 2 roll       % string string string1 string2
   2 index 0 3 index
   % string string string1 string2 string 0 string1
   putinterval    % stuff the first string in.
   % string string string1 string2
   exch length exch putinterval
} bind def

%=========================================================================
% Strings
/ban_string {
  (TOKEN_BAN_STRING)
} def
/ban_string_padded { % pads some space onto the string we're going to use for the endcaps
  ban_string (   ) append
} def
/subban_string {
  (TOKEN_SUBBAN_STRING)
} def
/date_string {
  (TOKEN_DATE)
} def

% Font Procedures

% Cover
/cover_ban_font { banfont findfont
  banfont bansize ban_string cover_width_printable auto_reduce_font
  scalefont setfont} def
banfont bansize ban_string cover_width_printable auto_reduce_font
/cover_ban_size exch def

/cover_subban_font { subbanfont findfont
  subbanfont subbansize subban_string cover_width_printable auto_reduce_font
  scalefont setfont} def
subbanfont subbansize subban_string cover_width_printable auto_reduce_font
/cover_subban_size exch def
% Tray
/tray_ban_font { banfont findfont
  banfont bansize ban_string tray_width_printable auto_reduce_font
  scalefont setfont} def
  banfont bansize ban_string tray_width_printable auto_reduce_font
/tray_ban_size exch def

/tray_subban_font { subbanfont findfont
  subbanfont subbansize subban_string tray_width_printable auto_reduce_font
  scalefont setfont} def
  subbanfont subbansize subban_string tray_width_printable auto_reduce_font
/tray_subban_size exch def

% if no ban_string or subban_string, don't print plaque on traycard
ban_string length subban_string length add 0 le
{ /print_traycard_plaque_p 0 def } if

% Endcaps
/datefont { notefontname findfont datefontsize scalefont setfont} def
/date_width {
  datefont
  date_string stringwidth pop
} def
/cap_notefont {notefontname findfont
  notefontname notefontsize ban_string_padded tray_height date_width sub auto_reduce_font
  scalefont setfont} def

/normalfont { normalfontname findfont normalfontsize scalefont setfont} def

% mar 01 avinash: empty ban or subban, don't print that line
ban_string length 0 le { /cover_ban_size 0 def /tray_ban_size 0 def } if
subban_string length 0 le { /cover_subban_size 0 def /tray_subban_size 0 def } if
date_string length 0 le { /date_height 0 def /date_width 0 def } if

/cover_items [
TOKEN_ITEMS_COVER
] def

/tray_items [
TOKEN_ITEMS_TRAY
] def

%=========================================================================

% Determine how wide we want to make the plaque
/cover_plaque_width {
  gsave
     cover_ban_font
     ban_string stringwidth pop
     cover_subban_font
     subban_string stringwidth pop gt
     { cover_ban_font ban_string stringwidth pop}
     { cover_subban_font subban_string stringwidth pop}
     ifelse
     (  ) stringwidth pop 2 sub add % add a little breathing room
  grestore
} def

/cover_plaque_height {
  cover_ban_size cover_subban_size add
 cover_ban_size 8 div cover_subban_size 6 div 2 mul add add
%9  cover_ban_size 8 div cover_subban_size 8 div 2 mul add add
} def

/tray_plaque_width {
  gsave
     tray_ban_font
     ban_string stringwidth pop
     tray_subban_font
     subban_string stringwidth pop gt
     { tray_ban_font ban_string stringwidth pop}
     { tray_subban_font subban_string stringwidth pop}
     ifelse
     (  ) stringwidth pop 2 sub add % add a little breathing room
  grestore
} def

/tray_plaque_height {
  tray_ban_size tray_subban_size add
  tray_ban_size 8 div tray_subban_size 8 div 2 mul add add
} def

% This is for dealing with epsfiles that do a showpage
/BEGINEPSFILE {
  /EPSFsave save def
  0 setgray
  0 setlinecap
  1 setlinewidth
  0 setlinejoin
  10 setmiterlimit
  [] 0 setdash
  newpath
  /showpage {} def
  } bind def

% This is for dealing with epsfiles that do a showpage
/ENDEPSFILE {
  EPSFsave restore
  } bind def

/box { % stack: width height linewidth
  gsave
      dup % linewidth linewidth
      epsilon le {
	pop pop pop % nothing to do
      } {
	setlinewidth % uses up linewidth on stack

	/height exch def
	/width exch def
	0 setlinecap

	width 0 rlineto
	0 height rlineto
	width neg 0 rlineto
	0 height neg rlineto
	closepath

	stroke
      }
      ifelse
  grestore
} def

/boxcutlines { % stack: left right top bottom width height
% 10 10 10 10 <width> <height> boxcutlines will make
% lines of length 10 on left, right, top, bottom of box

  % draw guide lines... 
  gsave
      /height exch def
      /width exch def
      /bottomlines exch def
      /toplines exch def
      /rightlines exch def
      /leftlines exch def

      0 setlinecap
      [4 7] 4 setdash
      0.4 setlinewidth

      gsave
        leftlines 0 gt { leftlines neg 0 rlineto  leftlines 0 rmoveto } if
        bottomlines 0 gt { 0 bottomlines neg rlineto } if
        stroke
      grestore

      gsave
        width 0 rmoveto
        rightlines 0 gt { rightlines 0 rlineto    rightlines neg 0 rmoveto } if
        bottomlines 0 gt { 0 bottomlines neg rlineto } if
        stroke
      grestore

      gsave
        width height rmoveto
        toplines 0 gt { 0 toplines rlineto    0 toplines neg rmoveto } if
        rightlines 0 gt { rightlines 0 rlineto } if
        stroke
      grestore

      gsave
        0 height rmoveto
        toplines 0 gt { 0 toplines rlineto    0 toplines neg rmoveto } if
        leftlines 0 gt { leftlines neg 0 rlineto } if
        stroke
      grestore

  grestore
} def

% Centers something inside something else. Put a string obj and a width onto the stack first
/centerstring {
exch dup stringwidth pop 3 -1 roll exch sub 2 div 0 rmoveto show
} def

/centerobject { %stack: width within with which to center, objwidth
  sub 2 div 0 rmoveto
} def

% show a string without moving (or so they think!)
/show_at {
  dup show stringwidth pop neg 0 rmoveto
} def

% This prints the text in the endcaps
/endcap_text {
  gsave
     gsave
	% set color for title (added by alessandro aug 02)
	r_category_color g_category_color b_category_color setrgbcolor
       cap_notefont notespacer ban_string_padded dup show stringwidth pop
       /tempx exch def
     grestore
       % If our ban_string_padded + subban_string is wider than the width
       % of the endcap minus the width of the date, then don't print the
       % subban_string width available to us
     tray_height date_width sub
     % length of the two strings (use the padded string, since that is printed)
     cap_notefont ban_string_padded stringwidth pop
     normalfont subban_string stringwidth pop
     add
     ytextspacer add % spacer between text
     gt {
       tempx 0 rmoveto
       normalfont
       0 ytextspacer rmoveto
       %set color for subtitle (added by alessandro aug 02)
       gsave
	r_subcategory_color g_subcategory_color b_subcategory_color setrgbcolor
       subban_string show
       grestore
     } if
  grestore
    r_text_color g_text_color b_text_color setrgbcolor % use text color for date
  datefont date_string dup stringwidth pop tray_height exch sub ytextspacer sub ytextspacer rmoveto show
} def

% For the plaque
/plaquepath {
  plaquewidth      0           rlineto
  0      plaqueheight       rlineto
  plaquewidth neg 0         rlineto
  0      plaqueheight neg   rlineto
  closepath
} def

% Draw a nice plaque with a small shadow
% --Based on a ps-print proc from emacs
/plaque { % Stack: width and height
  gsave
     /plaqueheight exch def
     /plaquewidth exch def
    0.4 setlinewidth
    % ---- fill a black rectangle (the shadow of the next one)
     gsave
        2 -2 rmoveto
        plaquepath
        gsave 0 setgray fill grestore
        % ---- do the next rectangle ...
     grestore
     plaquepath
     closepath
     % filled with color (added by alessandro aug 02)
     gsave
     r_plaque_color g_plaque_color b_plaque_color setrgbcolor
     fill
     grestore
    gsave 0 setgray stroke grestore % drawn  with black
  grestore
} def

%=========================================================================
%PostScript Blue Book Program 10, on page 167
%Creator: Adobe Systems Incorporated 
%CreationDate: Thu Dec 28 13:14:59 PST 1989

% This program defines two different procedures for
% printing text around a circular arc. outsidecircletext
% prints the text in a clockwise fashion with its baseline
% along the circumference, on the outside of the circle.
% insidecircletext prints the text in a counter-clockwise
% fashion with its baseline along the circumference, on the
% inside of the circle.
%
% Functions take four arguments: the string to
% show, the point size of the font to use, the angle around
% which the text should be centered, and the radius of the
% circular arc. It assumes that the center of the circle is at (0,0).

/outsidecircletext
  { circtextdict begin
	  /radius exch def
	  /centerangle exch def
	  /ptsize exch def
	  /str exch def
	  /xradius radius ptsize 4 div add def

	  gsave
	    centerangle str findhalfangle add rotate
	    str
		  { /charcode exch def
		    ( ) dup 0 charcode put outsideplacechar
		  } forall
	  grestore
	end
  } def
  
/insidecircletext
  { circtextdict begin
	  /radius exch def  /centerangle exch def
	  /ptsize exch def  /str exch def
	  
	  /xradius radius ptsize 3 div sub def
	  gsave
	    centerangle str findhalfangle sub rotate
	    str
		  { /charcode exch def
		    ( ) dup 0 charcode put insideplacechar
		  } forall
	  grestore
	end
  } def
  
/circtextdict 16 dict def
circtextdict begin
  /findhalfangle
	{ stringwidth pop 2 div
	  2 xradius mul pi mul div 360 mul
	} def
	
/outsideplacechar
  { /char exch def
	/halfangle char findhalfangle def
	gsave
	  halfangle neg rotate
	  radius 0 translate
	  -90 rotate
	  char stringwidth pop 2 div neg 0 moveto
	  char show
	grestore
	halfangle 2 mul neg rotate
  } def
  
/insideplacechar
  { /char exch def
	/halfangle char findhalfangle def
	gsave
	  halfangle rotate
	  radius 0 translate
	  90 rotate
	  char stringwidth pop 2 div neg 0 moveto
	  char show
	grestore
	halfangle 2 mul rotate
  } def
  
/pi 3.1415923 def
end

% Usage:
% /Times-Bold findfont 22 scalefont setfont
% translate the origin to the center of the page.
% 306 448 translate
% (Symphony No. 9 (The Choral Symphony)) 22 90 140 outsidecircletext
  
% /Times-Roman findfont 15 scalefont setfont
% (Ludwig von Beethoven) 15 90 118 outsidecircletext
% (The New York Philharmonic Orchestra) 15 270 118 insidecircletext
  
%=========================================================================
% avinash: jun 2001
% the list of items is printed here
% the number of items can be very large, and each item may be very long too.
% Need to maximize the line height based on number of columns to be used.
% But - do not go lower than the min_item_line_height.
% here are two procs that compute height & width for 1 to max_columns,
% and leave the values in an array

% fx_ are functions that do some computation

% for 1 .. max_columns, find the line_height to use, so that all items
% can be printed in that many columns
/fx_item_heights { % column_height num_items --> [item_height] (uses max_columns)
    % fx_item_height(cols)  ==   column_height / ( ceiling(num_items/cols) ) 
    /num_items exch def
    /col_height exch def

    [ % collect all values in an array
    1 1 max_columns {
      col_height exch num_items exch 
      % now have: col_height num_items forindex
      div ceiling div
    } for
    ]
} def

% for 1 .. max_columns, find the char width (font size) to use
% for the longest string, so that it fits completely in one column
/fx_item_widths { % fontname long_string --> [item_width]  
    % fx_item_width(cols)  ==  auto_reduce long_string, width:tray_width / cols 
    % (uses tray_width_printable, max_columns)
    /long_string exch def
    /itemfontname exch def

    [ % collect all values in an array
    1 1 max_columns {
      tray_width_printable exch div column_gutter sub /max_width exch def
      % see what a 1,000pt width would be scaled to - the actual font
      % size to use...
      itemfontname 1000 long_string max_width auto_reduce_font
    } for
    ]
} def

% get_longest_string will go through the items array, find the
% string taking the longest length.
% Is approx - commands like {#BI} are considered part of the string,
% so such characters can throw off the calculation, but should
% be good enough for the purpose of finding the longest string.

/get_longest_string { % -->  (fontname) (longest string)   [uses iitems array]

    /longest_font_size 1000 def  % largest font size - smallest item width
    /longest_string () def
    /longest_fontname normalfontname def

    /max_width tray_width_printable column_gutter 2 mul sub def
    iitems {

      determine_font % expand on keywords in string in items
      /itemfontname exch def
      /item_string exch def

      /current_font_size
        itemfontname 1000 item_string max_width auto_reduce_font
      def

      current_font_size longest_font_size lt {
        /longest_font_size current_font_size def
        /longest_string item_string def
        /longest_fontname itemfontname def
      } if
    } forall

    % (longest string) == longest_string == %debug

    % leave this on the stack
    longest_fontname
    longest_string
} def

% determine_line_height - maximize line height (and so font size), 
% without having to leave out any items. If needed, is ok to clip/reduce
% each item.
% given two arrays (each with max_columns elements) containing
% item heights and widths, determines the best value to use for the
% item size (font size)
% heights: [h1 h2 h3 h4 ... ]
% widths:  [w1 w2 w3 w4 ... ]
% returns:  MAX(  MIN(h1, w1),  MIN(h2, w2),   MIN(h3, w3), ... )

/determine_line_height { % [ fx_item_widths ] [fx_item_heights ] --> num_cols line_height

  /item_heights exch def
  /item_widths exch def

  % (in determine line_height - heights, widths) == %debug
  % item_heights == %debug
  % item_widths == %debug

  % first normalize the item_widths:
  % since line_heights == % item_size + line_item_diff
  [
  item_widths {
    line_item_diff add
  } forall
  ]
  /item_widths exch def

  % first pass at determining best fit:
  % use both line_heights and item_widths, find their intersection
  % and choose number of columns that maximizes both line_height
  % and item_width
  /current_max 0 def
  /current_num_columns 0 def

  0 1   max_columns 1 sub {
      /i exch def

      /lh item_heights i get def
      /iw item_widths  i get def

      % get smaller value
      lh iw lt {
        /iw lh def % make both same (smallest)...
      } {
        /lh iw def % make both same (smallest)...
      } ifelse

      % now lh is the smaller value - ignore values out of range
      % is this bigger than our stored value?
      lh current_max gt {
        /current_max lh def
        /current_num_columns i 1 add def
      } if

  } for

  % (first pass: computed num_cols and line height) == %debug
  % current_num_columns == %debug
  % current_max == %debug

  % if the values were out of range, second pass:
  % since both line_heights and item_widths cannot be optimized,
  % ignore item_widths (since items can be clipped or scaled anyway,
  % while ignoring line_height limitations would mean throwing away
  % items).
  % in this pass, we find the minimum number of columns needed to
  % fit all the items.

  current_max max_item_line_height gt {
    /current_max max_item_line_height def
    /current_num_columns 0 def
  } if

  % if the value is small, then we need to use the min font size,
  % given that, find the number of columns that are needed for the
  % given number of items 

  current_max min_item_line_height lt {
    /current_max min_item_line_height def
    /current_num_columns 0 def
  } if

  current_num_columns 1 lt {

      % compute number of columns, use the items_height - find the
      % lowest index that has a value greater than needed font size

      /current_num_columns 0 def
      item_heights {

        dup

        /current_num_columns current_num_columns 1 add def % [i]

        current_max gt { % item_heights[i] > current_max 

          % found number of columns, now get font size from item_heights
          % this will make the font size as large as possible for
          % number of columns and given number of items, but may end
          % up truncating or reducing long items far more than needed.
          % alternatively - could leave current_max as it is - that
          % would make the long items fit better (lesser clipping)
          % july 2001: going with larger font size, and more truncate...
          % comment out next line (replace with "pop")
          % if better fitting of items is needed...

          /current_max exch def % use font size as indicated by item_heights

          exit
        } if
        pop
      } forall

    % (second pass computed num_cols and line height) == %debug
    % current_num_columns == %debug
    % current_max == %debug

  } if

  % final catch all check, make sure values are in range
  current_max min_item_line_height lt { /current_max min_item_line_height def } if
  current_max max_item_line_height gt { /current_max max_item_line_height def } if
  current_num_columns 1 lt { /current_num_columns 1 def } if

  % return both values
  % (computed num_cols and line height) == %debug
  % current_num_columns == %debug
  % current_max == %debug

  current_num_columns
  current_max
} def

% determine font name based on input keywords, also strip
% input string of key words
% if keywords found {#BI}, {#B}, {#I} or {#M} apply bold-italic, bold, etc
/determine_font { % input_string --> output_string fontname

  /itemfontname normalfontname def

  (\{#BI\}) anchorsearch {
    pop
    % set font to bold and italic
    /itemfontname BIitemfontname def % bold-italic item font name
    } if
  (\{#I\}) anchorsearch {
    pop
    % set font to italic
    /itemfontname Iitemfontname def % italic item font name
    } if
  (\{#B\}) anchorsearch {
    pop
    % set font to bold
    /itemfontname Bitemfontname def % italic item font name
    } if
  (\{#M\}) anchorsearch {
    pop
    % set font to monospaced
    /itemfontname Mitemfontname def % monospaced item font name
    } if
  (\{#MB\}) anchorsearch {
    pop
    % set font to monospaced
    /itemfontname MBitemfontname def % monospaced item font name
    } if

   % now, on stack is the string left by anchorsearch - original
   % string (if no match), or the string after removal of keywords

   % add fontname to stack
   itemfontname
} def

% =======================================================================

% print list of given items,  in given box (tray or cover)
% the caller should position currentpoint to top left corner of box
% also assumes Y=0 is bottom left corner, so height == current y position

/print_items { % width itemsarray -->

    /iitems exch def % name iitems used by get_longest_string too
    /iwidth exch def

    % gsave (H) show grestore %debug

    gsave

    % leave border at top...
    0 column_gutter neg   rmoveto

    if_do_cd_inside_insert if_do_dvd_inside_insert or {
      % cover_height is larger than tray_height
      % to make same height apply, use up the difference (6.84pts), move down
    % 0 cover_height tray_height_normal sub neg rmoveto
      % note that this is to try to make the column of items look the same
      % whether printed on cover_and_tray or twopage_cover - but - the
      % cover has far smaller width, so definitely  the items could be
      % clipped/auto_reduce'd far more when printed in twopage.
    } if

    currentpoint
    /col_y exch def
    /col_x exch def

    /col_height col_y column_gutter sub def
    % this leaves a column_gutter space to left of first column
    % no need to do that - tray_margin or cover_margin takes care of margins!
    % /col_x col_x column_gutter add def % current x position of 1st column

    %=====================================================================
    % line_height is used to print each item, each item is printed
    % using "item_size" font size.

    % a somewhat complicated algorithm is used to determine best
    % line_height
    % Two factors affect this: number of items, and width of the largest
    % printed item.
    % The three procedures - get_longest_string, fx_item_widths,
    % fx_item_heights, are used to collect heights and widths for
    % a given range of columns (from 1 to max_columns), and
    % then the best choice is taken - to maximize line height.

    % for 1 .. max_columns, find the char width (font size) to use
    % for the longest string, so that it fits completely in one column
    get_longest_string fx_item_widths

    % for 1 .. max_columns, find the line_height to use, so that all items
    % can be printed in that many columns
    col_height    iitems length    fx_item_heights

    % with the above two arrays, find the best line_height to use
    determine_line_height

    /line_height exch def
    /num_cols exch def

    % (computed values for line_height, num_cols) == %debug
    % line_height == %debug
    % num_cols == %debug

    % if user has overriden computed line/cols values, use those instead
    % expected that both values will be provided, no sense in overriding
    % just one of the rows or columns numbers. cdlabelgen ensures this by
    % providing a single option name for both values (--rows-columns)
    force_count_rows 0 gt {
      /line_height    col_height force_count_rows div     def 
    } if
    force_count_cols 0 gt {
      /num_cols force_count_cols def
    } if

    % (using these values for line_height, num_cols) == %debug
    % line_height == %debug
    % num_cols == %debug

    % now that we've line-height, use it to compute font size
    /item_size line_height line_item_diff sub def

    % this leaves a column_gutter space to left of first column
    % no need to do that - tray_margin or cover_margin takes care of margins!
    % /col_width iwidth column_gutter sub num_cols div def
    /col_width iwidth column_gutter add num_cols div def

    % (col_height, width) == %debug
    % col_height == %debug
    % col_width == %debug

        % set our font
        /itemsfont
          { normalfontname findfont item_size scalefont setfont} def
        /itemfontname normalfontname def
        itemsfont

     gsave % saving for clip ...
        col_x 0   col_width column_gutter sub    col_y rectclip
        col_x col_y moveto

        % Print the items
        iitems {

          determine_font % expand on keywords
          /itemfontname exch def
          /item_string exch def

          /itemsfont
            { itemfontname findfont item_size scalefont setfont} def

          enable_item_scaling_p {
            % Scale down if the item is wider than the column.
            /itemsfont {
             itemfontname findfont
               itemfontname item_size item_string
               col_width 20 add column_gutter sub
               % autoreduce deducts 20pt from col_width, so adding...
               auto_reduce_font % on stack: font, pt size, string, max_width
             scalefont setfont} def
          } {
            % truncate item if the item is wider than the column.
            % this makes for better "clipping" - otherwise, just
            % using rectclip leaves half-letters on output..., this way
            % we leave out complete letters if they fall on the edge
            /item_string 
             itemfontname item_size item_string
             col_width 20 add column_gutter sub
             % autoreduce deducts 20pt from col_width, so adding...
             auto_reduce_string  % on stack: font, pt size, string, max_width
             def
          } ifelse

          itemsfont
          0 line_height neg rmoveto     % move down one line
	  %set color for text (added by alessandro (aug 02)
	  r_text_color g_text_color b_text_color setrgbcolor
          item_string show_at % show the text
          % Set the font back to normal size
          /itemfontname normalfontname def
          /itemsfont
            { normalfontname findfont item_size scalefont setfont} def
          % If we get to the bottom, move up and over!
          currentpoint exch pop epsilon_point add   line_height column_gutter add  lt
          {
             % (reached end of col) == %debug
             % currentpoint exch pop epsilon_point add == %debug
             % line_height column_gutter add  == %debug

             grestore
             /col_x col_x col_width add def

             gsave
                % If we move past the right edge of the tray_card,
                % then it's time to stop printing items - check end
                % of column is > iwidth
                col_x  epsilon_point add   iwidth gt
                {exit} if

             % set clip rectangle for current column...
             % (not really necessary to use rectclip, since am using
             % auto_reduce_string to clip strings, but leaving it here
             % just in case!)
             col_x 0   col_width column_gutter sub    col_y rectclip
             col_x col_y moveto

             itemsfont} if
        } forall
        grestore  % restore clip...
    grestore
} def % ----print_items

%=========================================================================
% print date for non-cd-label formats
/print_date_inserts {
  gsave
  % 20021102 <tmancill@debian.org> - position the date correctly
  % depending upon whether the cover plaque is desired
  datefont
  print_cover_plaque_p 0 gt {
     % We're now back in the bottom left corner of the cover
     % relocate to an appropriate place to put the date on the cover
       cover_width_printable date_string stringwidth pop sub 10 sub % X
       cover_height cover_plaque_height date_height add sub % Y
  } {
     % we need to position the date without deference to the plaque size
       cover_width_printable date_string stringwidth pop sub 10 sub % X
       cover_height date_height sub % Y
  } ifelse
  rmoveto
  r_text_color g_text_color b_text_color setrgbcolor % use text color for date
  date_string show
  grestore
} def
%=========================================================================
% print date for cd label - curved, inside the outer circle
/print_date_cdlabel {
  gsave
    datefont
    r_text_color g_text_color b_text_color setrgbcolor % use text color for date
    outer_radius dup translate
    date_string   datefontsize 270 outer_radius datefontsize 2 div sub insidecircletext
  grestore
} def
%=========================================================================
% First endcap
/first_endcap {
  gsave
     newpath
     0 0 moveto
     cap_width tray_height edge_line_width box
     rotate_endcaps_p
     { 0 tray_height moveto
       270 rotate }
     { cap_width 0 moveto
       90 rotate }
     ifelse
     endcap_text
  grestore
} def
%=========================================================================
% Second endcap
/second_endcap {
  cap_width tray_width add 0 moveto
  cap_width tray_height edge_line_width box
  gsave
     % Position ourselves to write in the endcap
     rotate_endcaps_p
     { tray_width cap_width 2 mul add 0 moveto
       90 rotate }
     { tray_width cap_width add tray_height moveto
       270 rotate }
     ifelse
     endcap_text
  grestore
} def
%=========================================================================
% Tongue endcap
/tongue_endcap {
  cap_width tray_width add cap_width add 0 moveto
  tng_width tray_height edge_line_width box
  gsave
     % Position ourselves to write in the endcap
     % Same as second endcap
     % tng_width cap_width sub 2 div tray_width cap_width add cap_width add add tray_height moveto
     % 270 rotate
     % Same as first endcap
     rotate_endcaps_p
     { tng_width cap_width sub 2 div tray_width cap_width 2 mul add add tray_height moveto
       270 rotate }
     { tng_width cap_width sub 2 div tray_width cap_width 3 mul add add 0 moveto
       90 rotate }
     ifelse
     endcap_text
  grestore
} def
%=========================================================================
/top_flap {
    /flap_height exch def

    0 setlinecap
    1.0 setlinewidth

    gsave 

    flap_height slope mul   % mul is percent slope factor
    flap_height rlineto 
    cover_width flap_height slope mul 2 mul sub 0 rlineto
    flap_height slope mul   flap_height neg   rlineto
    closepath
    stroke

    grestore 

    % print the tray plaque on the top flap also
    % AC: Apr 2002: commented out, the banner/sub-ban strings together
    % take around 1.2", while the top_flap is usually only around 0.6"
    % so, seems pointless to print the tray_plaque on the top flap...
    false {
      gsave
      % should print in top flap area only, use rectclip to restrict
      0 tray_height cover_height add   tray_width flap_height rectclip

      tray_width    tray_height cover_height add    moveto

      180 rotate
      tray_margin   -5 rmoveto
      tray_card_plaque
      grestore 
    } if
} def

/two_side_flaps {
    /flap_height exch def

    0 setlinecap
    1.0 setlinewidth

    % draw two side flaps
    flap_height neg    
    flap_height slope mul   % mul is percent slope factor
    rlineto
    0    cover_height flap_height slope mul 2 mul sub   rlineto
    flap_height
    flap_height slope mul   % mul is percent slope factor
    rlineto
    closepath
    tray_width    tray_height      moveto
    flap_height
    flap_height slope mul   % mul is percent slope factor
    rlineto
    0    cover_height flap_height slope mul 2 mul sub   rlineto
    flap_height neg
    flap_height slope mul   % mul is percent slope factor
    rlineto
    closepath

    stroke
} def

% =======================================================================
/tray_card_plaque {
  gsave
    % move down and start the box at the bottom of the text
    0 tray_plaque_height neg rmoveto
    % Center, then make the plaque
    tray_width_printable tray_plaque_width centerobject
    tray_plaque_width tray_plaque_height plaque
  grestore

  gsave
    % center and print the title (adjust y axis for hanging letters
    % like jy etc, so they don't go below plaque box outline)
    0   tray_ban_size 0.87 mul  neg    rmoveto 
	     
    gsave
	%set color for title (added by alessandro aug 02)
	r_category_color g_category_color b_category_color setrgbcolor
      tray_ban_font ban_string tray_width_printable centerstring
    grestore
    % then subtitle
    0    tray_subban_size tray_ban_size 8 div add neg     rmoveto
	%set color for subtitle (added by alessandro aug 02)
	r_subcategory_color g_subcategory_color b_subcategory_color setrgbcolor
    tray_subban_font subban_string tray_width_printable centerstring
  grestore
} def

% Back of the jewel box 
/tray_card {

    % Draw the box
    newpath
    0 0 moveto
    gsave
      tray_width tray_height edge_line_width box
    grestore

    % Move to the upper left corner of the tray_card
    tray_margin   tray_height 5 sub    moveto

    % (start of tray) == %debug
    % currentpoint == == %debug

    % Put this in a conditional so that we can optionally *not* print
    % the plaque on the traycard.
    print_traycard_plaque_p 0 gt {
      tray_card_plaque
      % Move down to a suitable position for printing the listing
      0 tray_plaque_height neg rmoveto
    } if

    % (before print items) == %debug
    % currentpoint == == %debug
    % gsave (H) show grestore %debug

    tray_width_printable tray_items print_items
} def
%=========================================================================
%cover
/cover {

  newpath

  % apr 01 avinash: draw cover at 0,0, calling procedure will
  % do the needed transformation (translate, translate/rotate) as needed.
  % original: 0 cover_height 25 add moveto

  0 0 moveto

  gsave
     cover_width cover_height edge_line_width box
  grestore

  cover_margin  -5  rmoveto

  % 20021103 <tmancill@debian.org> - check to see whether we want
  % the plaque on the (front) cover at all
  print_cover_plaque_p 0 gt {
     % if no title or subtitle (total length < 1), don't print plaque
     ban_string length subban_string length add
     1 ge
     {
       gsave
	0   cover_height  rmoveto
	gsave
           % move down and start the box at the bottom of the text
           0 cover_plaque_height neg rmoveto
           cover_width_printable cover_plaque_width centerobject
           cover_plaque_width cover_plaque_height plaque
	grestore

        % center and print the subtitle (adjust y axis for hanging letters
	% like jy etc, so they don't go below plaque box outline)
	0  cover_ban_size 0.89 mul  neg   rmoveto

	gsave
     	   %set color for title (added by alessandro aug 02)
	   r_category_color g_category_color b_category_color setrgbcolor
           cover_ban_font ban_string cover_width_printable centerstring
	grestore
	0 cover_subban_size cover_ban_size 8 div add neg rmoveto
	   %set color for subtitle (added by alessandro aug 02)
	   r_subcategory_color g_subcategory_color b_subcategory_color setrgbcolor
	cover_subban_font subban_string cover_width_printable centerstring
       grestore
     }
     if
  } 
  if   

  % --- show the date string
  if_do_cdlabel not {
     print_date_inserts
  } if
  % cdlabel date is printed curved, and in the cdlabel function, not part
  % of cover
  
  % print list of items, move to top right corner of cover
  0 % X
  print_cover_plaque_p 0 gt {
    cover_height    cover_plaque_height date_height add   sub % Y
  } {
    cover_height    date_height sub % Y
  } ifelse
  rmoveto

  % currentpoint == == %debug
  % gsave (H) show grestore %debug

  cover_width_printable cover_items print_items
} def

%=========================================================================
% These procedures do the actual printing for required CD cases

/do_normal_cdcase {
    % generate cover and tray_card for normal sized CD cases

     gsave
         cap_width    tray_height tray_cover_gap add translate
         % translate of y=tray_height makes it totally touching - requires
         % changes elsewhere too - image filling
         cover

         % left right top bottom width height boxcutlines
         tray_cover_gap 2 gt {
	   % plenty of gap between cover and tray, print all cutlines
           0 0 moveto
           300 300 300 0 cover_width cover_height boxcutlines
	 } {
	   % no gap between cover and tray, print top cutlines only
           0 cover_height moveto
           300 300 300 0 cover_width 0 boxcutlines
	 } ifelse

     grestore

     first_endcap

     gsave
         cap_width 0 translate
     tray_card

     cap_width neg 0 moveto
     % left right top bottom width height boxcutlines
     300 300 0 300
       tray_width tng_width cap_width cap_width add add add
       tray_height
       boxcutlines
     % fold lines...
     0 -10 moveto
     0 0 0 300 tray_width 0 boxcutlines
     tray_width -10 moveto
     0 0 0 300 cap_width 0 boxcutlines

     grestore

     second_endcap
     tongue_endcap


} def

%=========================================================================
/do_folding_cover {
    % apr 01: avinash: slim cases are half-height cases, do not have
    % place to keep tray card, only front cover is available.
    % So, in this case, a two page folding cover is printed - which gives
    % two pages. The outside cover is
    % normal "cover", and inside cover is tray_card made to fit in "cover"
    % dimensions.
    % Both are rotated so the printout can be cut and folded in middle to
    % be inserted in slim-cd cases.
    % Though primarily for slim-cases, this folding cover could also be
    % used in normal CD cases.
    % Oct 2003: dvd-inside/outside inserts also make use of this function

     gsave
       90 rotate
       0   tray_height neg translate
         % note: translate must be in current CTM - is 90 deg rotated!
       outside_foldout_p { cover } { tray_card } ifelse

       % left right top bottom width height boxcutlines
       0 0 moveto
       % outer cut lines, for both cover and tray
       300 300 300 300  tray_width cover_width add tray_cover_gap add cap_width add    tray_height   boxcutlines

     grestore

     % the optional spine (used for DVD outside cover only)
    gsave
    if_do_dvd_outside_cover {

       % mention middle cutline is a fold...
       normalfontname findfont 8 scalefont setfont
       cover_height cover_width 5 add neg moveto
       cover_height 7 add   cover_width 15 add  moveto
       (FOLDS) show

       90 rotate
         % note: translate must be in current CTM - is 90 deg rotated!
         % the tray_cover_gap add leaves a small gap, where the fold has to be
         % made

       cap_width neg    cover_height neg translate
       second_endcap

     } {
       % mention middle cutline is a fold...
       normalfontname findfont 8 scalefont setfont
       cover_height tray_cover_gap add 5 add    cover_width 3 add moveto
       (FOLD) show

     } ifelse
     grestore

     gsave
       90 rotate
       tray_width tray_cover_gap add cap_width add   cover_height neg translate
         % note: translate must be in current CTM - is 90 deg rotated!
         % the tray_cover_gap add leaves a small gap, where the fold has to be
         % made
       outside_foldout_p { tray_card } { cover } ifelse

       -0.5 -5 moveto
       % middle fold-lines
       0 0 300 300      cap_width neg    tray_height 10 add boxcutlines

     grestore
} def

%=========================================================================
/do_envelope {
     % draw the top folding and side flaps
     gsave

	% top
	0    tray_height cover_height add    moveto
	top_flap_height top_flap

	% sides (use cap_width as size)
        0    tray_height      moveto
	side_flap_width  two_side_flaps

     grestore 

     % print end-caps - text only - in the side flaps of the cover
     gsave
	% left endcap text
        rotate_endcaps_p { 
          side_flap_width cap_width sub 2 div neg   tray_height moveto
          90 rotate
        } { 
          side_flap_width cap_width add 2 div neg
	  tray_height cover_height add 
	  moveto
          270 rotate
        } ifelse
        endcap_text
     grestore 
     gsave
	% right endcap text
        rotate_endcaps_p { 
          side_flap_width cap_width sub 2 div tray_width add
	  tray_height cover_height add 
	  moveto
          270 rotate
        } { 
          tray_width  side_flap_width cap_width add 2 div add   tray_height moveto
          90 rotate
        } ifelse
        endcap_text
     grestore 

     % print cover - front side of envelope
     gsave
	0 tray_height translate
	cover
     grestore

     % print tray - rear side of envelope
     gsave
	tray_width tray_height translate
	180 rotate
	tray_card
     grestore

     % cut lines around the tray
     0 0 moveto
     300 300 0 300 tray_width tray_height boxcutlines 

     % cut lines around the top flap
     0 tray_height cover_height add tray_cover_gap add moveto
     300 300 0 0 cover_width top_flap_height boxcutlines

     % cut lines around side flaps
     side_flap_width neg tray_height moveto
     0 0 300 400 cover_width side_flap_width 2 mul add cover_height boxcutlines

} def

%=========================================================================
% direct printing on CD (or DVD) - inkjets can do this today, on
% appropriate CDs/DVDs
% 0,0 is lower left corner of the square enclosing the outer circle

% set clip path - to interior of the two circles
% use this to cut out any printing outside the CD printable area - helps
% prevent inkjets have to deal with any printing outside CD area
/do_cdlabel_clipping {
     newpath
     % outer circle
     outer_diameter    outer_radius    moveto
     outer_radius outer_radius outer_radius 0 360 arc closepath
     % inner circle
     outer_radius inner_radius add   outer_radius    moveto
     outer_radius outer_radius inner_radius 360 0 arcn closepath
     clip  %%DEBUG- comment this line for debugging
     newpath
} def

/do_cdlabel {
    gsave
     % draw circle outlines
     edge_line_width epsilon gt {
       newpath
       0 setgray
       edge_line_width setlinewidth
       outer_diameter    outer_radius    moveto
       outer_radius outer_radius outer_radius 0 360 arc closepath
       stroke
       edge_line_width setlinewidth
       outer_radius inner_radius add   outer_radius    moveto
       outer_radius outer_radius inner_radius 360 0 arcn closepath
       stroke
     } if

     do_cdlabel_clipping %% for DEBUG, comment this to see outline

     % override variables used by cover, tray_card, other routines
     /edge_line_width  0 def %% for DEBUG, comment this to see outline

     gsave
       outer_diameter cover_width sub 2 div
       outer_radius inner_radius add
       translate

       cover
     grestore

     print_date_cdlabel

     gsave
       outer_diameter tray_width sub 2 div
       outer_radius inner_radius sub tray_height sub
       translate

       tray_card
     grestore

    grestore
} def

%=========================================================================
% perform transformations needed to position tray image drawings
% used for printing the background tray image, or the overlay tray image
% uses globals: scaleratio tray_image_fill_all
% args: xoff  yoff    position_tray_image
/position_tray_image {
    /yoffset_arg exch def
    /xoffset_arg exch def

    % if scaleratio is 0.0, then use the "logo" file as background
    scaleratio abs epsilon le {

      /xscale tray_width  bound2x bound1x sub div def
      /yscale tray_height bound2y bound1y sub div def

      % modify xscale if needed
      trayimage_fill_all {
	if_do_normal_cdcase {
	  % jul 02 - fill endcaps, but not the "tongue" on the right
	  % - the tongue infact does not exist on normal cd covers
	  /xscale
	  tray_width cap_width cap_width add add bound2x
	  bound1x sub
	  div    def
	} { % else normal_cdcase
	  % nov 03 - fill tray+spine+cover...(slimcd, dvd_inside/outside)
	  /xscale
	  if_do_dvd_outside_cover
	    { tray_width cap_width cover_width add add }
	    { tray_width cover_width add } ifelse
	  bound2x bound1x sub
	  div    def
	} ifelse % normal_cdcase
      } if % trayimage_fill_all

      % for direct printing on CD, scaleratio = 0.0 implies fill entire disc
      if_do_cdlabel {
	/xscale outer_diameter bound2x bound1x sub div def
	/yscale outer_diameter bound2y bound1y sub div def
      } if

    } { % else scaleratio 0.0

      /xscale scaleratio def    
      /yscale scaleratio def

    } ifelse % scaleratio 0.0

    % -- tray card (or inside cover) logo
    if_do_normal_cdcase {

	  %move it to where we want to go.
	  trayimage_fill_all {
	    tray_width cap_width 2 mul add
	    bound2x bound1x sub xscale mul sub
	  } {
	    tray_width cap_width add bound2x bound1x sub xscale mul sub
	  } ifelse

	  0

	  translate

    } if
    if_do_cd_inside_insert if_do_dvd_inside_insert if_do_dvd_outside_cover or or {
	  % rotated, two page, cover insert only
	  tray_height
	  cover_width outside_foldout_p { 2 } { 1 } ifelse mul
	      bound2x bound1x sub xscale mul sub
	  translate

	  90 rotate

	  trayimage_fill_all {
	    if_do_dvd_outside_cover
	      { cap_width cover_width add  0 translate }
	      { cover_width   0 translate } ifelse
	  } if % trayimage_fill_all 
    } if
    if_do_envelope {
	bound2x bound1x sub xscale mul
	tray_height
	translate

	180 rotate
    } if
    if_do_cdlabel {
	  outer_diameter bound2x bound1x sub xscale mul sub
	  0
	  translate
    } if

    scaleratio abs epsilon ge { % i.e., not 0.0, not used as background
	% apply user provided translates to move the image
	xoffset_arg yoffset_arg translate
    } if

    %adjust origin of epsfile to be 0 0
    bound1x xscale mul neg bound1y yscale mul neg translate
    xscale yscale scale

    % debug - draws boundary around bounds
    % bound1x bound1y moveto   bound2x bound1x sub  bound2y bound1y sub 1 box
} def % ----position_tray_image

% End Procedures
%
%%EndProlog
%
%=========================================================================
%%Page: CD_DVD_Inserts_and_Labels 1
%=========================================================================

% And off we go
  % Position ourselves in a reasonable place - most new printers have only 
  % 0.2" to 0.3" of unprintable area around the edges - but some may have
  % a max of 0.5 to 0.75" unprintable area all around, to make this fit on
  % both "letter" (US) and "A4" (Europe) paper sizes, choose a appropriate
  % lower-left origin:
% 1.0 in   0.8 in   translate
xoffset   yoffset   translate
  % The x-axis translate of 1.0 works well, but A4 may need a 1.5" (4cm) y-axis
  % translate. But that makes the printout larger than a "letter" sized.
  % 0.8 or 0.9 is the max y-axis translate to make it fit on letter.
  % Preliminary reports from Europe suggest that 0.8" (2cm) should be
  % enough of a bottom border, and that the printout is usable.

if_do_envelope {
  % give us a bit more space on the top then the normal template
0 in      -0.5 in     translate 
} if

if_do_dvd_inside_insert {
  % give us a bit more space on the top and right then the normal template
-0.4 in      0 in     translate 
} if

if_do_dvd_outside_cover {
  % give us a bit more space on the top and right then the normal template
-0.4 in      -0.55 in     translate 
} if

if_do_cdlabel {
% no adjustment to original xoffset/yoffset, which may be user-supplied
do_cdlabel_clipping %% for DEBUG, comment this to see outline
} if

% =================================================================
% first print the logos - these logos may be large
% bitmaps that are to be used as background, so print the text after
% the logos.

% cover background ---------------------------------
% Also used as background for cdlabel - printing directly on the CD
% following token defines bounds and scaleratio for cover background:
TOKEN_EPS_BOUNDS

scaleratio abs epsilon le {
    % if scaleratio is 0, then use the "logo" file as background
    /xscale cover_width bound2x bound1x sub div def
    /yscale cover_height bound2y bound1y sub div def
    if_do_cdlabel {
      /xscale outer_diameter bound2x bound1x sub div def
      /yscale outer_diameter bound2y bound1y sub div def
    } if
  } {
    /xscale scaleratio def    /yscale scaleratio def
  } ifelse

gsave
%===================
BEGINEPSFILE
% -- outside cover logo
if_do_normal_cdcase {
      %move it to where we want to go.
      cover_width bound2x bound1x sub xscale mul sub cap_width add
      tray_height tray_cover_gap add
      translate
} if
if_do_cd_inside_insert if_do_dvd_inside_insert or if_do_dvd_outside_cover or {
      % rotated, two page, cover insert only
      tray_height
      cover_width outside_foldout_p { 1 } { 2 } ifelse mul
	      bound2x bound1x sub xscale mul sub   tray_cover_gap add
      translate

      90 rotate
      if_do_dvd_outside_cover { cap_width 0 translate } if
} if
if_do_envelope {
      cover_width bound2x bound1x sub xscale mul sub
      tray_height tray_cover_gap add
      translate
} if
if_do_cdlabel {
      outer_diameter bound2x bound1x sub xscale mul sub
      0
      translate
} if

% apply user provided translates to move the image
scaleratio abs epsilon ge { % i.e., not 0.0, not used as background
    % apply user provided translates to move the image
    cover_image_xoffset cover_image_yoffset translate
} if

%adjust origin of epsfile to be 0 0
bound1x xscale mul neg bound1y yscale mul neg translate
xscale yscale scale

% mar 01 avinash: add DSC commands to ignore embedded file comments
%%BeginDocument: cover
TOKEN_COVER_EPS
%%EndDocument

% debug - draws border around bounds
% bound1x bound1y moveto bound2x bound1x sub  bound2y bound1y sub box

grestore
ENDEPSFILE

% Graphic on the tray_card =========================================
BEGINEPSFILE

gsave

% follow token defines bounds and scaleratio and trayimage_fill_all
TOKEN_TRAY_CARD_BOUNDS

% sanity checks - when doing two page cover/envelope, no endcaps available
if_do_envelope if_do_cdlabel or {
    /trayimage_fill_all false def
} if

tray_image_xoffset tray_image_yoffset    position_tray_image

% mar 01 avinash: add DSC commands to ignore embedded file comments
%%BeginDocument: traycard
TOKEN_TRAY_CARD_EPS
%%EndDocument

grestore
ENDEPSFILE

% ---------------------------------
% now print the cover and tray card
if_do_normal_cdcase { do_normal_cdcase } if
if_do_cd_inside_insert { do_folding_cover } if
if_do_envelope { do_envelope } if
if_do_dvd_inside_insert { do_folding_cover } if
if_do_dvd_outside_cover { do_folding_cover } if
if_do_cdlabel { do_cdlabel } if

% Overlay Graphic on the tray_card =========================================
% this overprints on background as well as the list of items

BEGINEPSFILE
gsave

% follow token defines bounds and scaleratio
TOKEN_TRAY_OVERLAY_BOUNDS

% sanity checks - for overlay, no fill all
% xoff  yoff    position_tray_image
/trayimage_fill_all false def
tray_overlay_image_xoffset tray_overlay_image_yoffset    position_tray_image

%%BeginDocument: TrayOverlay
TOKEN_TRAY_OVERLAY_EPS
%%EndDocument

% draw box around overlay - maybe not?
% bound1x bound1y moveto   bound2x bound1x sub  bound2y bound1y sub edge_line_width box

grestore
ENDEPSFILE

% -------------------------------------------------------------
% printing signature ....
% Use up a little of the whitespace on the scrap part of the paper

if_do_cd_inside_insert if_do_dvd_inside_insert or if_do_dvd_outside_cover or {
  % 90 degrees rotated - swap height/width...
  tray_height 60 add
  tray_width 12 add    if_do_dvd_outside_cover { cap_width add } if
  moveto
} {
  if_do_cdlabel { % don't print any labels
    do_cdlabel_clipping
    outer_diameter 90 add
    outer_diameter 12 add
    moveto
  } {
    tray_width 90 add
    tray_height 12 add
    moveto
  } ifelse
} ifelse

90 rotate

0 15 rmoveto

normalfontname findfont 10 scalefont setfont

gsave
  (cdlabelgen 4.2.0 ) show
  /Symbol findfont 10 scalefont setfont (\343) show
  normalfontname findfont 10 scalefont setfont
  ( 2001-2008 Avinash Chopde <avinash@aczoom.com>) show
grestore
0 18 neg rmoveto

gsave
  (         home page:    ) show
  (http://www.aczoom.com/tools/cdinsert/) show
grestore
0 21 neg rmoveto

if_do_envelope {
  gsave
    normalfontname findfont 8 scalefont setfont
    (  envelope support: ) show
    (  Ronald Rael Harvest <number6@cox.net>,  March 2002) show
  grestore
  0 18 neg rmoveto
} if

%=========================================================================

showpage

%%EOF
